{
  "AngularJS Style Guide": {
    "order": "0",
    "About the App": {
      "content": "This app was made for fun by [Derek Severson](https://github.com/derekseverson) to explore the possibilities of the Ionic Framework and practice AngularJS skills.\n\nThe source code and content of this app is open sourced on github. [Go take a look.](https://github.com/derekseverson/AngularJS-StyleGuide-IonicApp).\n\nThis AngularJS Style Guide is a subcollection of the insightful AngularJS Style Guide by [@john_papa](http://twitter.com/john_papa) and other contributors.  John Papa's full version (not mobile) is located at this [github repo](https://github.com/johnpapa/angularjs-styleguide).\n",
      "order": "2"
    },
    "Opinionated Style Guide": {
      "content": "Opinionated AnguluarJS Style Guide for teams.\n\nThe purpose of this style guide is to provide guidance on building AngularJS applications by showing good conventions, more importantly, why they work well.  Code examples are abuntant.\n\nStart looking at the style guide sections via the top left menu button!  Enjoy!!!",
      "order": "1"
    }
  },
  "Annotating for DI": {
    "order": "10",
    "Manually Identify Dependencies": {
      "content": "\n  - Use `$inject` to manually identify your dependencies for AngularJS components.\n\n    *Why?*: This technique mirrors the technique used by [`ng-annotate`](https://github.com/olov/ng-annotate), which I recommend for automating the creation of minification safe dependencies. If `ng-annotate` detects injection has already been made, it will not duplicate it.\n\n    *Why?*: This safeguards your dependencies from being vulnerable to minification issues when parameters may be mangled. For example, `common` and `dataservice` may become `a` or `b` and not be found by AngularJS.\n\n    *Why?*: Avoid creating in-line dependencies as long lists can be difficult to read in the array. Also it can be confusing that the array is a series of strings while the last item is the component's function.\n\n    ```javascript\n    /* avoid */\n    angular\n        .module('app')\n        .controller('Dashboard',\n            ['$location', '$routeParams', 'common', 'dataservice',\n                function Dashboard($location, $routeParams, common, dataservice) {}\n            ]);\n    ```\n\n    ```javascript\n    /* avoid */\n    angular\n      .module('app')\n      .controller('Dashboard',\n          ['$location', '$routeParams', 'common', 'dataservice', Dashboard]);\n\n    function Dashboard($location, $routeParams, common, dataservice) {\n    }\n    ```\n\n    ```javascript\n    /* recommended */\n    angular\n        .module('app')\n        .controller('Dashboard', Dashboard);\n\n    Dashboard.$inject = ['$location', '$routeParams', 'common', 'dataservice'];\n\n    function Dashboard($location, $routeParams, common, dataservice) {\n    }\n    ```\n\n    Note: When your function is below a return statement the $inject may be unreachable (this may happen in a directive). You can solve this by either moving the $inject above the return statement or by using the alternate array injection syntax.\n\n    Note: [`ng-annotate 0.10.0`](https://github.com/olov/ng-annotate) introduced a feature where it moves the `$inject` to where it is reachable.\n\n    ```javascript\n    // inside a directive definition\n    function outer() {\n        return {\n            controller: DashboardPanel,\n        };\n\n        DashboardPanel.$inject = ['logger']; // Unreachable\n        function DashboardPanel(logger) {\n        }\n    }\n    ```\n\n    ```javascript\n    // inside a directive definition\n    function outer() {\n        DashboardPanel.$inject = ['logger']; // reachable\n        return {\n            controller: DashboardPanel,\n        };\n\n        function DashboardPanel(logger) {\n        }\n    }\n    ```\n",
      "order": "2"
    },
    "Route Resolver Dependencies": {
      "content": "\n  - Use $inject to manually identify your route resolver dependencies for AngularJS components.\n\n    *Why?*: This technique breaks out the anonymous function for the route resolver, making it easier to read.\n\n    *Why?*: An `$inject` statement can easily precede the resolver to handle making any dependencies minification safe.\n\n    ```javascript\n    /* recommended */\n    function config($routeProvider) {\n        $routeProvider\n            .when('/avengers', {\n                templateUrl: 'avengers.html',\n                controller: 'Avengers',\n                controllerAs: 'vm',\n                resolve: {\n                    moviesPrepService: moviePrepService\n                }\n            });\n    }\n\n    moviePrepService.$inject = ['movieService'];\n    function moviePrepService(movieService) {\n        return movieService.getMovies();\n    }\n    ```\n",
      "order": "3"
    },
    "Unsafe from Minification": {
      "content": "\n  - Avoid using the shortcut syntax of declaring dependencies without using a minification-safe approach.\n\n    *Why?*: The parameters to the component (e.g. controller, factory, etc) will be converted to mangled variables. For example, `common` and `dataservice` may become `a` or `b` and not be found by AngularJS.\n\n    ```javascript\n    /* avoid - not minification-safe*/\n    angular\n        .module('app')\n        .controller('Dashboard', Dashboard);\n\n    function Dashboard(common, dataservice) {\n    }\n    ```\n\n    This code may produce mangled variables when minified and thus cause runtime errors.\n\n    ```javascript\n    /* avoid - not minification-safe*/\n    angular.module('app').controller('Dashboard', d);function d(a, b) { }\n    ```\n",
      "order": "1"
    }
  },
  "Controllers": {
    "order": "4",
    "Assigning Controllers": {
      "content": "\n  - When a controller must be paired with a view and either component may be re-used by other controllers or views, define controllers along with their routes.\n\n    Note: If a View is loaded via another means besides a route, then use the `ng-controller=\"Avengers as vm\"` syntax.\n\n    *Why?*: Pairing the controller in the route allows different routes to invoke different pairs of controllers and views. When controllers are assigned in the view using [`ng-controller`](https://docs.angularjs.org/api/ng/directive/ngController), that view is always associated with the same controller.\n\n ```javascript\n  /* avoid - when using with a route and dynamic pairing is desired */\n\n  // route-config.js\n  angular\n      .module('app')\n      .config(config);\n\n  function config($routeProvider) {\n      $routeProvider\n          .when('/avengers', {\n            templateUrl: 'avengers.html'\n          });\n  }\n  ```\n\n  ```html\n  <!-- avengers.html -->\n  <div ng-controller=\"Avengers as vm\">\n  </div>\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // route-config.js\n  angular\n      .module('app')\n      .config(config);\n\n  function config($routeProvider) {\n      $routeProvider\n          .when('/avengers', {\n              templateUrl: 'avengers.html',\n              controller: 'Avengers',\n              controllerAs: 'vm'\n          });\n  }\n  ```\n\n  ```html\n  <!-- avengers.html -->\n  <div>\n  </div>\n  ```",
      "order": ""
    },
    "Bindable Members Up Top": {
      "content": "\n  - Place bindable members at the top of the controller, alphabetized, and not spread through the controller code.\n\n    *Why?*: Placing bindable members at the top makes it easy to read and helps you instantly identify which members of the controller can be bound and used in the View.\n\n    *Why?*: Setting anonymous functions in-line can be easy, but when those functions are more than 1 line of code they can reduce the readability. Defining the functions below the bindable members (the functions will be hoisted) moves the implementation details down, keeps the bindable members up top, and makes it easier to read.\n\n  ```javascript\n  /* avoid */\n  function Sessions() {\n      var vm = this;\n\n      vm.gotoSession = function() {\n        /* ... */\n      };\n      vm.refresh = function() {\n        /* ... */\n      };\n      vm.search = function() {\n        /* ... */\n      };\n      vm.sessions = [];\n      vm.title = 'Sessions';\n  ```\n\n  ```javascript\n  /* recommended */\n  function Sessions() {\n      var vm = this;\n\n      vm.gotoSession = gotoSession;\n      vm.refresh = refresh;\n      vm.search = search;\n      vm.sessions = [];\n      vm.title = 'Sessions';\n\n      ////////////\n\n      function gotoSession() {\n        /* */\n      }\n\n      function refresh() {\n        /* */\n      }\n\n      function search() {\n        /* */\n      }\n  ```\n\n  Note: If the function is a 1 liner consider keeping it right up top, as long as readability is not affected.\n\n  ```javascript\n  /* avoid */\n  function Sessions(data) {\n      var vm = this;\n\n      vm.gotoSession = gotoSession;\n      vm.refresh = function() {\n          /**\n           * lines\n           * of\n           * code\n           * affects\n           * readability\n           */\n      };\n      vm.search = search;\n      vm.sessions = [];\n      vm.title = 'Sessions';\n  ```\n\n  ```javascript\n  /* recommended */\n  function Sessions(dataservice) {\n      var vm = this;\n\n      vm.gotoSession = gotoSession;\n      vm.refresh = dataservice.refresh; // 1 liner is OK\n      vm.search = search;\n      vm.sessions = [];\n      vm.title = 'Sessions';\n  ```\n",
      "order": "4"
    },
    "Defer Controller Logic": {
      "content": "\n  - Defer logic in a controller by delegating to services and factories.\n\n    *Why?*: Logic may be reused by multiple controllers when placed within a service and exposed via a function.\n\n    *Why?*: Logic in a service can more easily be isolated in a unit test, while the calling logic in the controller can be easily mocked.\n\n    *Why?*: Removes dependencies and hides implementation details from the controller.\n\n  ```javascript\n\n  /* avoid */\n  function Order($http, $q, config, userInfo) {\n      var vm = this;\n      vm.checkCredit = checkCredit;\n      vm.isCreditOk;\n      vm.total = 0;\n\n      function checkCredit() {\n          var settings = {};\n          // Get the credit service base URL from config\n          // Set credit service required headers\n          // Prepare URL query string or data object with request data\n          // Add user-identifying info so service gets the right credit limit for this user.\n          // Use JSONP for this browser if it doesn't support CORS\n          return $http.get(settings)\n              .then(function(data) {\n               // Unpack JSON data in the response object\n                 // to find maxRemainingAmount\n                 vm.isCreditOk = vm.total <= maxRemainingAmount\n              })\n              .catch(function(error) {\n                 // Interpret error\n                 // Cope w/ timeout? retry? try alternate service?\n                 // Re-reject with appropriate error for a user to see\n              });\n      };\n  }\n  ```\n\n  ```javascript\n  /* recommended */\n  function Order(creditService) {\n      var vm = this;\n      vm.checkCredit = checkCredit;\n      vm.isCreditOk;\n      vm.total = 0;\n\n      function checkCredit() {\n         return creditService.isOrderTotalOk(vm.total)\n      .then(function(isOk) { vm.isCreditOk = isOk; })\n            .catch(showServiceError);\n      };\n  }\n  ```\n",
      "order": "6"
    },
    "Function Declarations": {
      "content": "\n  - Use function declarations to hide implementation details. Keep your bindable members up top. When you need to bind a function in a controller, point it to a function declaration that appears later in the file. This is tied directly to the section Bindable Members Up Top. For more details see [this post](http://www.johnpapa.net/angular-function-declarations-function-expressions-and-readable-code).\n\n    *Why?*: Placing bindable members at the top makes it easy to read and helps you instantly identify which members of the controller can be bound and used in the View. (Same as above.)\n\n    *Why?*: Placing the implementation details of a function later in the file moves that complexity out of view so you can see the important stuff up top.\n\n    *Why?*: Function declaration are hoisted so there are no concerns over using a function before it is defined (as there would be with function expressions).\n\n    *Why?*: You never have to worry with function declarations that moving `var a` before `var b` will break your code because `a` depends on `b`.\n\n    *Why?*: Order is critical with function expressions\n\n  ```javascript\n  /**\n   * avoid\n   * Using function expressions.\n   */\n  function Avengers(dataservice, logger) {\n      var vm = this;\n      vm.avengers = [];\n      vm.title = 'Avengers';\n\n      var activate = function() {\n          return getAvengers().then(function() {\n              logger.info('Activated Avengers View');\n          });\n      }\n\n      var getAvengers = function() {\n          return dataservice.getAvengers().then(function(data) {\n              vm.avengers = data;\n              return vm.avengers;\n          });\n      }\n\n      vm.getAvengers = getAvengers;\n\n      activate();\n  }\n  ```\n\n  Notice that the important stuff is scattered in the preceding example. In the example below, notice that the important stuff is up top. For example, the members bound to the controller such as `vm.avengers` and `vm.title`. The implementation details are down below. This is just easier to read.\n\n  ```javascript\n  /*\n   * recommend\n   * Using function declarations\n   * and bindable members up top.\n   */\n  function Avengers(dataservice, logger) {\n      var vm = this;\n      vm.avengers = [];\n      vm.getAvengers = getAvengers;\n      vm.title = 'Avengers';\n\n      activate();\n\n      function activate() {\n          return getAvengers().then(function() {\n              logger.info('Activated Avengers View');\n          });\n      }\n\n      function getAvengers() {\n          return dataservice.getAvengers().then(function(data) {\n              vm.avengers = data;\n              return vm.avengers;\n          });\n      }\n  }\n  ```",
      "order": "5"
    },
    "Keep Controllers Focused": {
      "content": "\n  - Define a controller for a view, and try not to reuse the controller for other views. Instead, move reusable logic to factories and keep the controller simple and focused on its view.\n\n    *Why?*: Reusing controllers with several views is brittle and good end to end (e2e) test coverage is required to ensure stability across large applications.\n",
      "order": "7"
    },
    "controllerAs Controller Syntax": {
      "content": "\n  - Use the `controllerAs` syntax over the `classic controller with $scope` syntax.\n\n  - The `controllerAs` syntax uses `this` inside controllers which gets bound to `$scope`\n\n  *Why?*: `controllerAs` is syntactic sugar over `$scope`. You can still bind to the View and still access `$scope` methods.\n\n  *Why?*: Helps avoid the temptation of using `$scope` methods inside a controller when it may otherwise be better to avoid them or move them to a factory. Consider using `$scope` in a factory, or if in a controller just when needed. For example when publishing and subscribing events using [`$emit`](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$emit), [`$broadcast`](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$broadcast), or [`$on`](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$on) consider moving these uses to a factory and invoke from the controller.\n\n  ```javascript\n  /* avoid */\n  function Customer($scope) {\n      $scope.name = {};\n      $scope.sendMessage = function() { };\n  }\n  ```\n\n  ```javascript\n  /* recommended - but see next section */\n  function Customer() {\n      this.name = {};\n      this.sendMessage = function() { };\n  }\n  ```",
      "order": "2"
    },
    "controllerAs View Syntax": {
      "content": "  - Use the [`controllerAs`](http://www.johnpapa.net/do-you-like-your-angular-controllers-with-or-without-sugar/) syntax over the `classic controller with $scope` syntax.\n\n  *Why?*: Controllers are constructed, \"newed\" up, and provide a single new instance, and the `controllerAs` syntax is closer to that of a JavaScript constructor than the `classic $scope syntax`.\n\n  *Why?*: It promotes the use of binding to a \"dotted\" object in the View (e.g. `customer.name` instead of `name`), which is more contextual, easier to read, and avoids any reference issues that may occur without \"dotting\".\n\n  *Why?*: Helps avoid using `$parent` calls in Views with nested controllers.\n\n  ```html\n  <!-- avoid -->\n  <div ng-controller=\"Customer\">\n      {{ name }}\n  </div>\n  ```\n\n  ```html\n  <!-- recommended -->\n  <div ng-controller=\"Customer as customer\">\n      {{ customer.name }}\n  </div>\n  ```",
      "order": "1"
    },
    "controllerAs with vm": {
      "content": "\n  - Use a capture variable for `this` when using the `controllerAs` syntax. Choose a consistent variable name such as `vm`, which stands for ViewModel.\n\n  *Why?*: The `this` keyword is contextual and when used within a function inside a controller may change its context. Capturing the context of `this` avoids encountering this problem.\n\n  ```javascript\n  /* avoid */\n  function Customer() {\n      this.name = {};\n      this.sendMessage = function() { };\n  }\n  ```\n\n  ```javascript\n  /* recommended */\n  function Customer() {\n      var vm = this;\n      vm.name = {};\n      vm.sendMessage = function() { };\n  }\n  ```\n\n  Note: You can avoid any [jshint](http://www.jshint.com/) warnings by placing the comment below above the line of code. However it is not needed when the function is named using UpperCasing, as this convention means it is a constructor function, which is what a controller is in Angular.\n\n  ```javascript\n  /* jshint validthis: true */\n  var vm = this;\n  ```\n\n  Note: When creating watches in a controller using `controller as`, you can watch the `vm.*` member using the following syntax. (Create watches with caution as they add more load to the digest cycle.)\n\n  ```html\n  <input ng-model=\"vm.title\"/>\n  ```\n\n  ```javascript\n  function SomeController($scope, $log) {\n      var vm = this;\n      vm.title = 'Some Title';\n\n      $scope.$watch('vm.title', function(current, original) {\n          $log.info('vm.title was %s', original);\n          $log.info('vm.title is now %s', current);\n      });\n  }\n  ```",
      "order": "3"
    }
  },
  "Data Services": {
    "order": "7",
    "Return a Promise": {
      "content": "\n  - When calling a data service that returns a promise such as $http, return a promise in your calling function too.\n\n    *Why?*: You can chain the promises together and take further action after the data call completes and resolves or rejects the promise.\n\n  ```javascript\n  /* recommended */\n\n  activate();\n\n  function activate() {\n      /**\n       * Step 1\n       * Ask the getAvengers function for the\n       * avenger data and wait for the promise\n       */\n      return getAvengers().then(function() {\n          /**\n           * Step 4\n           * Perform an action on resolve of final promise\n           */\n          logger.info('Activated Avengers View');\n      });\n  }\n\n  function getAvengers() {\n        /**\n         * Step 2\n         * Ask the data service for the data and wait\n         * for the promise\n         */\n        return dataservice.getAvengers()\n            .then(function(data) {\n                /**\n                 * Step 3\n                 * set the data and resolve the promise\n                 */\n                vm.avengers = data;\n                return vm.avengers;\n        });\n  }\n  ```",
      "order": "2"
    },
    "Separate Data Calls": {
      "content": "\n  - Refactor logic for making data operations and interacting with data to a factory. Make data services responsible for XHR calls, local storage, stashing in memory, or any other data operations.\n\n    *Why?*: The controller's responsibility is for the presentation and gathering of information for the view. It should not care how it gets the data, just that it knows who to ask for it. Separating the data services moves the logic on how to get it to the data service, and lets the controller be simpler and more focused on the view.\n\n    *Why?*: This makes it easier to test (mock or real) the data calls when testing a controller that uses a data service.\n\n    *Why?*: Data service implementation may have very specific code to handle the data repository. This may include headers, how to talk to the data, or other services such as $http. Separating the logic into a data service encapsulates this logic in a single place hiding the implementation from the outside consumers (perhaps a controller), also making it easier to change the implementation.\n\n  ```javascript\n  /* recommended */\n\n  // dataservice factory\n  angular\n      .module('app.core')\n      .factory('dataservice', dataservice);\n\n  dataservice.$inject = ['$http', 'logger'];\n\n  function dataservice($http, logger) {\n      return {\n          getAvengers: getAvengers\n      };\n\n      function getAvengers() {\n          return $http.get('/api/maa')\n              .then(getAvengersComplete)\n              .catch(getAvengersFailed);\n\n          function getAvengersComplete(response) {\n              return response.data.results;\n          }\n\n          function getAvengersFailed(error) {\n              logger.error('XHR Failed for getAvengers.' + error.data);\n          }\n      }\n  }\n  ```\n\n    Note: The data service is called from consumers, such as a controller, hiding the implementation from the consumers, as shown below.\n\n  ```javascript\n  /* recommended */\n\n  // controller calling the dataservice factory\n  angular\n      .module('app.avengers')\n      .controller('Avengers', Avengers);\n\n  Avengers.$inject = ['dataservice', 'logger'];\n\n  function Avengers(dataservice, logger) {\n      var vm = this;\n      vm.avengers = [];\n\n      activate();\n\n      function activate() {\n          return getAvengers().then(function() {\n              logger.info('Activated Avengers View');\n          });\n      }\n\n      function getAvengers() {\n          return dataservice.getAvengers()\n              .then(function(data) {\n                  vm.avengers = data;\n                  return vm.avengers;\n              });\n      }\n  }\n  ```\n",
      "order": "1"
    }
  },
  "Directives": {
    "order": "8",
    "BindToController Syntax": {
      "content": "\n  - Use `bindToController = true` when using `controller as` syntax with a directive when you want to bind the outer scope to the directive's controller's scope.\n\n    *Why?*: It makes it easy to bind outer scope to the directive's controller scope.\n\n    Note: `bindToController` was introduced in Angular 1.3.0.\n\n  ```html\n  <div my-example max=\"77\"></div>\n  ```\n\n  ```javascript\n  angular\n      .module('app')\n      .directive('myExample', myExample);\n\n  function myExample() {\n      var directive = {\n          restrict: 'EA',\n          templateUrl: 'app/feature/example.directive.html',\n          scope: {\n              max: '='\n          },\n          controller: ExampleController,\n            controllerAs: 'vm',\n            bindToController: true\n        };\n\n      return directive;\n  }\n\n  function ExampleController() {\n      var vm = this;\n      vm.min = 3;\n      console.log('CTRL: vm.min = %s', vm.min);\n      console.log('CTRL: vm.max = %s', vm.max);\n  }\n  ```\n\n  ```html\n  <!-- example.directive.html -->\n  <div>hello world</div>\n  <div>max={{vm.max}}<input ng-model=\"vm.max\"/></div>\n  <div>min={{vm.min}}<input ng-model=\"vm.min\"/></div>\n  ```",
      "order": "6"
    },
    "Directives and ControllerAs": {
      "content": "\n  - Use `controller as` syntax with a directive to be consistent with using `controller as` with view and controller pairings.\n\n    *Why?*: It makes sense and it's not difficult.\n\n    Note: The directive below demonstrates some of the ways you can use scope inside of link and directive controllers, using controllerAs. I in-lined the template just to keep it all in one place.\n\n    Note: Regarding dependency injection, see [Manually Identify Dependencies](#manual-annotating-for-dependency-injection).\n\n    Note: Note that the directive's controller is outside the directive's closure. This style eliminates issues where the injection gets created as unreachable code after a `return`.\n\n  ```html\n  <div my-example max=\"77\"></div>\n  ```\n\n  ```javascript\n  angular\n      .module('app')\n      .directive('myExample', myExample);\n\n  function myExample() {\n      var directive = {\n          restrict: 'EA',\n          templateUrl: 'app/feature/example.directive.html',\n          scope: {\n              max: '='\n          },\n          link: linkFunc,\n          controller: ExampleController,\n            controllerAs: 'vm',\n            bindToController: true // because the scope is isolated\n        };\n\n      return directive;\n\n      function linkFunc(scope, el, attr, ctrl) {\n          console.log('LINK: scope.min = %s *** should be undefined', scope.min);\n          console.log('LINK: scope.max = %s *** should be undefined', scope.max);\n          console.log('LINK: scope.vm.min = %s', scope.vm.min);\n          console.log('LINK: scope.vm.max = %s', scope.vm.max);\n      }\n  }\n\n  ExampleController.$inject = ['$scope'];\n\n  function ExampleController($scope) {\n      // Injecting $scope just for comparison\n      var vm = this;\n\n      vm.min = 3;\n\n      console.log('CTRL: $scope.vm.min = %s', $scope.vm.min);\n      console.log('CTRL: $scope.vm.max = %s', $scope.vm.max);\n      console.log('CTRL: vm.min = %s', vm.min);\n      console.log('CTRL: vm.max = %s', vm.max);\n  }\n  ```\n\n  ```html\n  <!-- example.directive.html -->\n  <div>hello world</div>\n  <div>max={{vm.max}}<input ng-model=\"vm.max\"/></div>\n  <div>min={{vm.min}}<input ng-model=\"vm.min\"/></div>\n  ```\n",
      "order": "5"
    },
    "Limit 1 Per File": {
      "content": "\n  - Create one directive per file. Name the file for the directive.\n\n    *Why?*: It is easy to mash all the directives in one file, but difficult to then break those out so some are shared across apps, some across modules, some just for one module.\n\n    *Why?*: One directive per file is easy to maintain.\n\n  ```javascript\n  /* avoid */\n  /* directives.js */\n\n  angular\n      .module('app.widgets')\n\n      /* order directive that is specific to the order module */\n      .directive('orderCalendarRange', orderCalendarRange)\n\n      /* sales directive that can be used anywhere across the sales app */\n      .directive('salesCustomerInfo', salesCustomerInfo)\n\n      /* spinner directive that can be used anywhere across apps */\n      .directive('sharedSpinner', sharedSpinner);\n\n  function orderCalendarRange() {\n      /* implementation details */\n  }\n\n  function salesCustomerInfo() {\n      /* implementation details */\n  }\n\n  function sharedSpinner() {\n      /* implementation details */\n  }\n  ```\n\n  ```javascript\n  /* recommended */\n  /* calendarRange.directive.js */\n\n  /**\n   * @desc order directive that is specific to the order module at a company named Acme\n   * @example <div acme-order-calendar-range></div>\n   */\n  angular\n      .module('sales.order')\n      .directive('acmeOrderCalendarRange', orderCalendarRange);\n\n  function orderCalendarRange() {\n      /* implementation details */\n  }\n  ```\n\n  ```javascript\n  /* recommended */\n  /* customerInfo.directive.js */\n\n  /**\n   * @desc spinner directive that can be used anywhere across the sales app at a company named Acme\n   * @example <div acme-sales-customer-info></div>\n   */\n  angular\n      .module('sales.widgets')\n      .directive('acmeSalesCustomerInfo', salesCustomerInfo);\n\n  function salesCustomerInfo() {\n      /* implementation details */\n  }\n  ```\n\n  ```javascript\n  /* recommended */\n  /* spinner.directive.js */\n\n  /**\n   * @desc spinner directive that can be used anywhere across apps at a company named Acme\n   * @example <div acme-shared-spinner></div>\n   */\n  angular\n      .module('shared.widgets')\n      .directive('acmeSharedSpinner', sharedSpinner);\n\n  function sharedSpinner() {\n      /* implementation details */\n  }\n  ```\n\n    Note: There are many naming options for directives, especially since they can be used in narrow or wide scopes. Choose one that makes the directive and it's file name distinct and clear. Some examples are below, but see the naming section for more recommendations.\n",
      "order": "1"
    },
    "Manipulate DOM in a Directive": {
      "content": "\n  - When manipulating the DOM directly, use a directive. If alternative ways can be used such as using CSS to set styles or the [animation services](https://docs.angularjs.org/api/ngAnimate), Angular templating, [`ngShow`](https://docs.angularjs.org/api/ng/directive/ngShow) or [`ngHide`](https://docs.angularjs.org/api/ng/directive/ngHide), then use those instead. For example, if the directive simply hides and shows, use ngHide/ngShow.\n\n    *Why?*: DOM manipulation can be difficult to test, debug, and there are often better ways (e.g. CSS, animations, templates)\n",
      "order": "2"
    },
    "Restrict to Elements and Attributes": {
      "content": "\n  - When creating a directive that makes sense as a stand-alone element, allow restrict `E` (custom element) and optionally restrict `A` (custom attribute). Generally, if it could be its own control, `E` is appropriate. General guideline is allow `EA` but lean towards implementing as an element when its stand-alone and as an attribute when it enhances its existing DOM element.\n\n    *Why?*: It makes sense.\n\n    *Why?*: While we can allow the directive to be used as a class, if the directive is truly acting as an element it makes more sense as an element or at least as an attribute.\n\n    Note: EA is the default for AngularJS 1.3 +\n\n  ```html\n  <!-- avoid -->\n  <div class=\"my-calendar-range\"></div>\n  ```\n\n  ```javascript\n  /* avoid */\n  angular\n      .module('app.widgets')\n      .directive('myCalendarRange', myCalendarRange);\n\n  function myCalendarRange() {\n      var directive = {\n          link: link,\n          templateUrl: '/template/is/located/here.html',\n          restrict: 'C'\n      };\n      return directive;\n\n      function link(scope, element, attrs) {\n        /* */\n      }\n  }\n  ```\n\n  ```html\n  <!-- recommended -->\n  <my-calendar-range></my-calendar-range>\n  <div my-calendar-range></div>\n  ```\n\n  ```javascript\n  /* recommended */\n  angular\n      .module('app.widgets')\n      .directive('myCalendarRange', myCalendarRange);\n\n  function myCalendarRange() {\n      var directive = {\n          link: link,\n          templateUrl: '/template/is/located/here.html',\n          restrict: 'EA'\n      };\n      return directive;\n\n      function link(scope, element, attrs) {\n        /* */\n      }\n  }\n  ```\n",
      "order": "4"
    },
    "Unique Directive Prefix": {
      "content": "\n  - Provide a short, unique and descriptive directive prefix such as `acmeSalesCustomerInfo` which is declared in HTML as `acme-sales-customer-info`.\n\n    *Why?*: The unique short prefix identifies the directive's context and origin. For example a prefix of `cc-` may indicate that the directive is part of a CodeCamper app while `acme-` may indicate a directive for the Acme company.\n\n    Note: Avoid `ng-` as these are reserved for AngularJS directives. Research widely used directives to avoid naming conflicts, such as `ion-` for the [Ionic Framework](http://ionicframework.com/).\n",
      "order": "3"
    }
  },
  "Exception Handling": {
    "order": "12",
    "Decorators": {
      "content": "\n  - Use a [decorator](https://docs.angularjs.org/api/auto/service/$provide#decorator), at config time using the [`$provide`](https://docs.angularjs.org/api/auto/service/$provide) service, on the [`$exceptionHandler`](https://docs.angularjs.org/api/ng/service/$exceptionHandler) service to perform custom actions when exceptions occur.\n\n    *Why?*: Provides a consistent way to handle uncaught AngularJS exceptions for development-time or run-time.\n\n    Note: Another option is to override the service instead of using a decorator. This is a fine option, but if you want to keep the default behavior and extend it a decorator is recommended.\n\n    ```javascript\n    /* recommended */\n    angular\n        .module('blocks.exception')\n        .config(exceptionConfig);\n\n    exceptionConfig.$inject = ['$provide'];\n\n    function exceptionConfig($provide) {\n        $provide.decorator('$exceptionHandler', extendExceptionHandler);\n    }\n\n    extendExceptionHandler.$inject = ['$delegate', 'toastr'];\n\n    function extendExceptionHandler($delegate, toastr) {\n        return function(exception, cause) {\n            $delegate(exception, cause);\n            var errorData = {\n                exception: exception,\n                cause: cause\n            };\n            /**\n             * Could add the error to a service's collection,\n             * add errors to $rootScope, log errors to remote web server,\n             * or log locally. Or throw hard. It is entirely up to you.\n             * throw exception;\n             */\n            toastr.error(exception.msg, errorData);\n        };\n    }\n    ```\n",
      "order": "1"
    },
    "Exception Catchers": {
      "content": "\n  - Create a factory that exposes an interface to catch and gracefully handle exceptions.\n\n    *Why?*: Provides a consistent way to catch exceptions that may be thrown in your code (e.g. during XHR calls or promise failures).\n\n    Note: The exception catcher is good for catching and reacting to specific exceptions from calls that you know may throw one. For example, when making an XHR call to retrieve data from a remote web service and you want to catch any exceptions from that service and react uniquely.\n\n    ```javascript\n    /* recommended */\n    angular\n        .module('blocks.exception')\n        .factory('exception', exception);\n\n    exception.$inject = ['logger'];\n\n    function exception(logger) {\n        var service = {\n            catcher: catcher\n        };\n        return service;\n\n        function catcher(message) {\n            return function(reason) {\n                logger.error(message, reason);\n            };\n        }\n    }\n    ```\n",
      "order": "2"
    },
    "Route Errors": {
      "content": "\n  - Handle and log all routing errors using [`$routeChangeError`](https://docs.angularjs.org/api/ngRoute/service/$route#$routeChangeError).\n\n    *Why?*: Provides a consistent way handle all routing errors.\n\n    *Why?*: Potentially provides a better user experience if a routing error occurs and you route them to a friendly screen with more details or recovery options.\n\n    ```javascript\n    /* recommended */\n    function handleRoutingErrors() {\n        /**\n         * Route cancellation:\n         * On routing error, go to the dashboard.\n         * Provide an exit clause if it tries to do it twice.\n         */\n        $rootScope.$on('$routeChangeError',\n            function(event, current, previous, rejection) {\n                var destination = (current && (current.title || current.name || current.loadedTemplateUrl)) ||\n                    'unknown target';\n                var msg = 'Error routing to ' + destination + '. ' + (rejection.msg || '');\n                /**\n                 * Optionally log using a custom service or $log.\n                 * (Don't forget to inject custom service)\n                 */\n                logger.warning(msg, [current]);\n            }\n        );\n    }\n    ```\n",
      "order": "3"
    }
  },
  "IIFE": {
    "order": "2",
    "JavaScript Closures": {
      "content": "\n  - Wrap AngularJS components in an Immediately Invoked Function Expression (IIFE).\n\n  *Why?*: An IIFE removes variables from the global scope. This helps prevent variables and function declarations from living longer than expected in the global scope, which also helps avoid variable collisions.\n\n  *Why?*: When your code is minified and bundled into a single file for deployment to a production server, you could have collisions of variables and many global variables. An IIFE protects you against both of these by providing variable scope for each file.\n\n  ```javascript\n  /* avoid */\n  // logger.js\n  angular\n      .module('app')\n      .factory('logger', logger);\n\n  // logger function is added as a global variable\n  function logger() { }\n\n  // storage.js\n  angular\n      .module('app')\n      .factory('storage', storage);\n\n  // storage function is added as a global variable\n  function storage() { }\n  ```\n\n  ```javascript\n  /**\n   * recommended\n   *\n   * no globals are left behind\n   */\n\n  // logger.js\n  (function() {\n      'use strict';\n\n      angular\n          .module('app')\n          .factory('logger', logger);\n\n      function logger() { }\n  })();\n\n  // storage.js\n  (function() {\n      'use strict';\n\n      angular\n          .module('app')\n          .factory('storage', storage);\n\n      function storage() { }\n  })();\n  ```\n\n  - Note: For brevity only, the rest of the examples in this guide may omit the IIFE syntax.\n\n  - Note: IIFE's prevent test code from reaching private members like regular expressions or helper functions which are often good to unit test directly on their own. However you can test these through accessible members or by exposing them through their own component. For example placing helper functions, regular expressions or constants in their own factory or constant.\n",
      "order": "1"
    }
  },
  "Modules": {
    "order": "3",
    "Avoid Naming Collisions": {
      "content": "  - Use unique naming conventions with separators for sub-modules.\n\n  *Why?*: Unique names help avoid module name collisions. Separators help define modules and their submodule hierarchy. For example `app` may be your root module while `app.dashboard` and `app.users` may be modules that are used as dependencies of `app`.\n",
      "order": "1"
    },
    "Definitions aka Setters": {
      "content": "\n  - Declare modules without a variable using the setter syntax.\n\n  *Why?*: With 1 component per file, there is rarely a need to introduce a variable for the module.\n\n  ```javascript\n  /* avoid */\n  var app = angular.module('app', [\n      'ngAnimate',\n      'ngRoute',\n      'app.shared',\n      'app.dashboard'\n  ]);\n  ```\n\n  Instead use the simple setter syntax.\n\n  ```javascript\n  /* recommended */\n  angular\n      .module('app', [\n          'ngAnimate',\n          'ngRoute',\n          'app.shared',\n          'app.dashboard'\n      ]);\n  ```\n",
      "order": "2"
    },
    "Getters": {
      "content": "\n  - When using a module, avoid using a variable and instead use chaining with the getter syntax.\n\n  *Why?*: This produces more readable code and avoids variable collisions or leaks.\n\n  ```javascript\n  /* avoid */\n  var app = angular.module('app');\n  app.controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```\n\n  ```javascript\n  /* recommended */\n  angular\n      .module('app')\n      .controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```\n",
      "order": "3"
    },
    "Named vs Anonymous Functions": {
      "content": "\n  - Use named functions instead of passing an anonymous function in as a callback.\n\n  *Why?*: This produces more readable code, is much easier to debug, and reduces the amount of nested callback code.\n\n  ```javascript\n  /* avoid */\n  angular\n      .module('app')\n      .controller('Dashboard', function() { })\n      .factory('logger', function() { });\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // dashboard.js\n  angular\n      .module('app')\n      .controller('Dashboard', Dashboard);\n\n  function Dashboard() { }\n  ```\n\n  ```javascript\n  // logger.js\n  angular\n      .module('app')\n      .factory('logger', logger);\n\n  function logger() { }\n  ```\n",
      "order": "5"
    },
    "Setting vs Getting": {
      "content": "\n  - Only set once and get for all other instances.\n\n  *Why?*: A module should only be created once, then retrieved from that point and after.\n\n    - Use `angular.module('app', []);` to set a module.\n    - Use `angular.module('app');` to get a module.\n",
      "order": "4"
    }
  },
  "Naming": {
    "order": "13",
    "Controller Name Suffix": {
      "content": "\n  - Append the controller name with the suffix `Controller` or with no suffix. Choose 1, not both.\n\n    *Why?*: The `Controller` suffix is more commonly used and is more explicitly descriptive.\n\n    *Why?*: Omitting the suffix is more succinct and the controller is often easily identifiable even without the suffix.\n\n    ```javascript\n    /**\n     * recommended: Option 1\n     */\n\n    // avengers.controller.js\n    angular\n        .module\n        .controller('Avengers', Avengers);\n\n    function Avengers() { }\n    ```\n\n    ```javascript\n    /**\n     * recommended: Option 2\n     */\n\n    // avengers.controller.js\n    angular\n        .module\n        .controller('AvengersController', AvengersController);\n\n    function AvengersController() { }\n    ```\n",
      "order": "5"
    },
    "Controller Names": {
      "content": "\n  - Use consistent names for all controllers named after their feature. Use UpperCamelCase for controllers, as they are constructors.\n\n    *Why?*: Provides a consistent way to quickly identify and reference controllers.\n\n    *Why?*: UpperCamelCase is conventional for identifying object that can be instantiated using a constructor.\n\n    ```javascript\n    /**\n     * recommended\n     */\n\n    // avengers.controller.js\n    angular\n        .module\n        .controller('HeroAvengers', HeroAvengers);\n\n    function HeroAvengers() { }\n    ```\n",
      "order": "4"
    },
    "Directive Component Names": {
      "content": "\n  - Use consistent names for all directives using camel-case. Use a short prefix to describe the area that the directives belong (some example are company prefix or project prefix).\n\n    *Why?*: Provides a consistent way to quickly identify and reference components.\n\n    ```javascript\n    /**\n     * recommended\n     */\n\n    // avenger-profile.directive.js\n    angular\n        .module\n        .directive('xxAvengerProfile', xxAvengerProfile);\n\n    // usage is <xx-avenger-profile> </xx-avenger-profile>\n\n    function xxAvengerProfile() { }\n    ```\n",
      "order": "7"
    },
    "Factory Names": {
      "content": "\n  - Use consistent names for all factories named after their feature. Use camel-casing for services and factories.\n\n    *Why?*: Provides a consistent way to quickly identify and reference factories.\n\n    ```javascript\n    /**\n     * recommended\n     */\n\n    // logger.service.js\n    angular\n        .module\n        .factory('logger', logger);\n\n    function logger() { }\n    ```\n",
      "order": "6"
    },
    "Feature File Names": {
      "content": "\n  - Use consistent names for all components following a pattern that describes the component's feature then (optionally) its type. My recommended pattern is `feature.type.js`.\n\n    *Why?*: Provides a consistent way to quickly identify components.\n\n    *Why?*: Provides pattern matching for any automated tasks.\n\n    ```javascript\n    /**\n     * common options\n     */\n\n    // Controllers\n    avengers.js\n    avengers.controller.js\n    avengersController.js\n\n    // Services/Factories\n    logger.js\n    logger.service.js\n    loggerService.js\n    ```\n\n    ```javascript\n    /**\n     * recommended\n     */\n\n    // controllers\n    avengers.controller.js\n    avengers.controller.spec.js\n\n    // services/factories\n    logger.service.js\n    logger.service.spec.js\n\n    // constants\n    constants.js\n\n    // module definition\n    avengers.module.js\n\n    // routes\n    avengers.routes.js\n    avengers.routes.spec.js\n\n    // configuration\n    avengers.config.js\n\n    // directives\n    avenger-profile.directive.js\n    avenger-profile.directive.spec.js\n    ```\n\n  Note: Another common convention is naming controller files without the word `controller` in the file name such as `avengers.js` instead of `avengers.controller.js`. All other conventions still hold using a suffix of the type. Controllers are the most common type of component so this just saves typing and is still easily identifiable. I recommend you choose 1 convention and be consistent for your team.\n\n    ```javascript\n    /**\n     * recommended\n     */\n    // Controllers\n    avengers.js\n    avengers.spec.js\n    ```\n",
      "order": "2"
    },
    "Module Naming": {
      "content": "\n  - When there are multiple modules, the main module file is named `app.module.js` while other dependent modules are named after what they represent. For example, an admin module is named `admin.module.js`. The respective registered module names would be `app` and `admin`.\n\n    *Why?*: Provides consistency for multiple module apps, and for expanding to large applications.\n\n    *Why?*: Provides easy way to use task automation to load all module definitions first, then all other angular files (for bundling).\n",
      "order": "8"
    },
    "Naming Guidelines": {
      "content": "\n  - Use consistent names for all components following a pattern that describes the component's feature then (optionally) its type. My recommended pattern is `feature.type.js`. There are 2 names for most assets:\n    * the file name (`avengers.controller.js`)\n    * the registered component name with Angular (`AvengersController`)\n\n    *Why?*: Naming conventions help provide a consistent way to find content at a glance. Consistency within the project is vital. Consistency with a team is important. Consistency across a company provides tremendous efficiency.\n\n    *Why?*: The naming conventions should simply help you find your code faster and make it easier to understand.\n",
      "order": "1"
    },
    "Test File Names": {
      "content": "\n  - Name test specifications similar to the component they test with a suffix of `spec`.\n\n    *Why?*: Provides a consistent way to quickly identify components.\n\n    *Why?*: Provides pattern matching for [karma](http://karma-runner.github.io/) or other test runners.\n\n    ```javascript\n    /**\n     * recommended\n     */\n    avengers.controller.spec.js\n    logger.service.spec.js\n    avengers.routes.spec.js\n    avenger-profile.directive.spec.js\n    ```\n",
      "order": "3"
    }
  },
  "Resolving Promises": {
    "order": "9",
    "Controller Activation Promises": {
      "content": "\n  - Resolve start-up logic for a controller in an `activate` function.\n\n    *Why?*: Placing start-up logic in a consistent place in the controller makes it easier to locate, more consistent to test, and helps avoid spreading out the activation logic across the controller.\n\n    *Why?*: The controller `activate` makes it convenient to re-use the logic for a refresh for the controller/View, keeps the logic together, gets the user to the View faster, makes animations easy on the `ng-view` or `ui-view`, and feels snappier to the user.\n\n    Note: If you need to conditionally cancel the route before you start use the controller, use a [route resolve](#style-y081) instead.\n\n  ```javascript\n  /* avoid */\n  function Avengers(dataservice) {\n      var vm = this;\n      vm.avengers = [];\n      vm.title = 'Avengers';\n\n      dataservice.getAvengers().then(function(data) {\n          vm.avengers = data;\n          return vm.avengers;\n      });\n  }\n  ```\n\n  ```javascript\n  /* recommended */\n  function Avengers(dataservice) {\n      var vm = this;\n      vm.avengers = [];\n      vm.title = 'Avengers';\n\n      activate();\n\n      ////////////\n\n      function activate() {\n          return dataservice.getAvengers().then(function(data) {\n              vm.avengers = data;\n              return vm.avengers;\n          });\n      }\n  }\n  ```\n",
      "order": "1"
    },
    "Route Resolve Promises": {
      "content": "\n  - When a controller depends on a promise to be resolved before the controller is activated, resolve those dependencies in the `$routeProvider` before the controller logic is executed. If you need to conditionally cancel a route before the controller is activated, use a route resolver.\n\n  - Use a route resolve when you want to decide to cancel the route before ever transitioning to the View.\n\n    *Why?*: A controller may require data before it loads. That data may come from a promise via a custom factory or [$http](https://docs.angularjs.org/api/ng/service/$http). Using a [route resolve](https://docs.angularjs.org/api/ngRoute/provider/$routeProvider) allows the promise to resolve before the controller logic executes, so it might take action based on that data from the promise.\n\n    *Why?*: The code executes after the route and in the controller’s activate function. The View starts to load right away. Data binding kicks in when the activate promise resolves. A “busy” animation can be shown during the view transition (via ng-view or ui-view)\n\n    Note: The code executes before the route via a promise. Rejecting the promise cancels the route. Resolve makes the new view wait for the route to resolve. A “busy” animation can be shown before the resolve and through the view transition. If you want to get to the View faster and do not require a checkpoint to decide if you can get to the View, consider the [controller `activate` technique](#style-y080) instead.\n\n  ```javascript\n  /* avoid */\n  angular\n      .module('app')\n      .controller('Avengers', Avengers);\n\n  function Avengers(movieService) {\n      var vm = this;\n      // unresolved\n      vm.movies;\n      // resolved asynchronously\n      movieService.getMovies().then(function(response) {\n          vm.movies = response.movies;\n      });\n  }\n  ```\n\n  ```javascript\n  /* better */\n\n  // route-config.js\n  angular\n      .module('app')\n      .config(config);\n\n  function config($routeProvider) {\n      $routeProvider\n          .when('/avengers', {\n              templateUrl: 'avengers.html',\n              controller: 'Avengers',\n              controllerAs: 'vm',\n              resolve: {\n                  moviesPrepService: function(movieService) {\n                      return movieService.getMovies();\n                  }\n              }\n          });\n  }\n\n  // avengers.js\n  angular\n      .module('app')\n      .controller('Avengers', Avengers);\n\n  Avengers.$inject = ['moviesPrepService'];\n  function Avengers(moviesPrepService) {\n        var vm = this;\n        vm.movies = moviesPrepService.movies;\n  }\n  ```\n\n    Note: The example below shows the route resolve points to a named function, which is easier to debug and easier to handle dependency injection.\n\n  ```javascript\n  /* even better */\n\n  // route-config.js\n  angular\n      .module('app')\n      .config(config);\n\n  function config($routeProvider) {\n      $routeProvider\n          .when('/avengers', {\n              templateUrl: 'avengers.html',\n              controller: 'Avengers',\n              controllerAs: 'vm',\n              resolve: {\n                  moviesPrepService: moviesPrepService\n              }\n          });\n  }\n\n  function moviePrepService(movieService) {\n      return movieService.getMovies();\n  }\n\n  // avengers.js\n  angular\n      .module('app')\n      .controller('Avengers', Avengers);\n\n  Avengers.$inject = ['moviesPrepService'];\n  function Avengers(moviesPrepService) {\n        var vm = this;\n        vm.movies = moviesPrepService.movies;\n  }\n  ```\n    Note: The code example's dependency on `movieService` is not minification safe on its own. For details on how to make this code minification safe, see the sections on [dependency injection](#manual-annotating-for-dependency-injection) and on [minification and annotation](#minification-and-annotation).\n",
      "order": "2"
    }
  },
  "Services and Factories": {
    "order": "6",
    "Accessible Members Up Top": {
      "content": "\n  - Expose the callable members of the service (it's interface) at the top, using a technique derived from the [Revealing Module Pattern](http://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript).\n\n    *Why?*: Placing the callable members at the top makes it easy to read and helps you instantly identify which members of the service can be called and must be unit tested (and/or mocked).\n\n    *Why?*: This is especially helpful when the file gets longer as it helps avoid the need to scroll to see what is exposed.\n\n    *Why?*: Setting functions as you go can be easy, but when those functions are more than 1 line of code they can reduce the readability and cause more scrolling. Defining the callable interface via the returned service moves the implementation details down, keeps the callable interface up top, and makes it easier to read.\n\n  ```javascript\n  /* avoid */\n  function dataService() {\n    var someValue = '';\n    function save() {\n      /* */\n    };\n    function validate() {\n      /* */\n    };\n\n    return {\n        save: save,\n        someValue: someValue,\n        validate: validate\n    };\n  }\n  ```\n\n  ```javascript\n  /* recommended */\n  function dataService() {\n      var someValue = '';\n      var service = {\n          save: save,\n          someValue: someValue,\n          validate: validate\n      };\n      return service;\n\n      ////////////\n\n      function save() {\n          /* */\n      };\n\n      function validate() {\n          /* */\n      };\n  }\n  ```\n\n  This way bindings are mirrored across the host object, primitive values cannot update alone using the revealing module pattern\n",
      "order": "3"
    },
    "Factory Singletons": {
      "content": "\n  - Factories are singletons and return an object that contains the members of the service.\n\n    Note: [All AngularJS services are singletons](https://docs.angularjs.org/guide/services).\n",
      "order": "2"
    },
    "Function Declarations": {
      "content": "\n  - Use function declarations to hide implementation details. Keep your accessible members of the factory up top. Point those to function declarations that appears later in the file. For more details see [this post](http://www.johnpapa.net/angular-function-declarations-function-expressions-and-readable-code).\n\n    *Why?*: Placing accessible members at the top makes it easy to read and helps you instantly identify which functions of the factory you can access externally.\n\n    *Why?*: Placing the implementation details of a function later in the file moves that complexity out of view so you can see the important stuff up top.\n\n    *Why?*: Function declaration are hoisted so there are no concerns over using a function before it is defined (as there would be with function expressions).\n\n    *Why?*: You never have to worry with function declarations that moving `var a` before `var b` will break your code because `a` depends on `b`.\n\n    *Why?*: Order is critical with function expressions\n\n  ```javascript\n  /**\n   * avoid\n   * Using function expressions\n   */\n   function dataservice($http, $location, $q, exception, logger) {\n      var isPrimed = false;\n      var primePromise;\n\n      var getAvengers = function() {\n          // implementation details go here\n      };\n\n      var getAvengerCount = function() {\n          // implementation details go here\n      };\n\n      var getAvengersCast = function() {\n         // implementation details go here\n      };\n\n      var prime = function() {\n         // implementation details go here\n      };\n\n      var ready = function(nextPromises) {\n          // implementation details go here\n      };\n\n      var service = {\n          getAvengersCast: getAvengersCast,\n          getAvengerCount: getAvengerCount,\n          getAvengers: getAvengers,\n          ready: ready\n      };\n\n      return service;\n  }\n  ```\n\n  ```javascript\n  /**\n   * recommended\n   * Using function declarations\n   * and accessible members up top.\n   */\n  function dataservice($http, $location, $q, exception, logger) {\n      var isPrimed = false;\n      var primePromise;\n\n      var service = {\n          getAvengersCast: getAvengersCast,\n          getAvengerCount: getAvengerCount,\n          getAvengers: getAvengers,\n          ready: ready\n      };\n\n      return service;\n\n      ////////////\n\n      function getAvengers() {\n          // implementation details go here\n      }\n\n      function getAvengerCount() {\n          // implementation details go here\n      }\n\n      function getAvengersCast() {\n          // implementation details go here\n      }\n\n      function prime() {\n          // implementation details go here\n      }\n\n      function ready(nextPromises) {\n          // implementation details go here\n      }\n  }\n  ```\n  \n",
      "order": "4"
    },
    "Service Singletons": {
      "content": "\n  - Services are instantiated with the `new` keyword, use `this` for public methods and variables. Since these are so similar to factories, use a factory instead for consistency.\n\n    Note: [All AngularJS services are singletons](https://docs.angularjs.org/guide/services). This means that there is only one instance of a given service per injector.\n\n  ```javascript\n  // service\n  angular\n      .module('app')\n      .service('logger', logger);\n\n  function logger() {\n    this.logError = function(msg) {\n      /* */\n    };\n  }\n  ```\n\n  ```javascript\n  // factory\n  angular\n      .module('app')\n      .factory('logger', logger);\n\n  function logger() {\n      return {\n          logError: function(msg) {\n            /* */\n          }\n     };\n  }\n  ```",
      "order": "1"
    }
  },
  "Single Responsibility": {
    "order": "1",
    "Rule of 1": {
      "content": "\n  - Define 1 component per file.\n\n  The following example defines the `app` module and its dependencies, defines a controller, and defines a factory all in the same file.\n\n  ```javascript\n  /* avoid */\n  angular\n      .module('app', ['ngRoute'])\n      .controller('SomeController', SomeController)\n      .factory('someFactory', someFactory);\n\n  function SomeController() { }\n\n  function someFactory() { }\n  ```\n\n  The same components are now separated into their own files.\n\n  ```javascript\n  /* recommended */\n\n  // app.module.js\n  angular\n      .module('app', ['ngRoute']);\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // someController.js\n  angular\n      .module('app')\n      .controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // someFactory.js\n  angular\n      .module('app')\n      .factory('someFactory', someFactory);\n\n  function someFactory() { }\n  ```",
      "order": "1"
    }
  }
}