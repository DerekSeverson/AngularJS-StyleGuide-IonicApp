{
  "IIFE": {
    "JavaScript Closures": {
      "code": "\n  ```javascript\n  /* avoid */\n  // logger.js\n  angular\n      .module('app')\n      .factory('logger', logger);\n\n  // logger function is added as a global variable\n  function logger() { }\n\n  // storage.js\n  angular\n      .module('app')\n      .factory('storage', storage);\n\n  // storage function is added as a global variable\n  function storage() { }\n  ```\n\n  ```javascript\n  /**\n   * recommended\n   *\n   * no globals are left behind\n   */\n\n  // logger.js\n  (function() {\n      'use strict';\n\n      angular\n          .module('app')\n          .factory('logger', logger);\n\n      function logger() { }\n  })();\n\n  // storage.js\n  (function() {\n      'use strict';\n\n      angular\n          .module('app')\n          .factory('storage', storage);\n\n      function storage() { }\n  })();\n  ```",
      "content": "\n  - Wrap AngularJS components in an Immediately Invoked Function Expression (IIFE).\n\n  *Why?*: An IIFE removes variables from the global scope. This helps prevent variables and function declarations from living longer than expected in the global scope, which also helps avoid variable collisions.\n\n  *Why?*: When your code is minified and bundled into a single file for deployment to a production server, you could have collisions of variables and many global variables. An IIFE protects you against both of these by providing variable scope for each file.\n\n  ```javascript\n  /* avoid */\n  // logger.js\n  angular\n      .module('app')\n      .factory('logger', logger);\n\n  // logger function is added as a global variable\n  function logger() { }\n\n  // storage.js\n  angular\n      .module('app')\n      .factory('storage', storage);\n\n  // storage function is added as a global variable\n  function storage() { }\n  ```\n\n  ```javascript\n  /**\n   * recommended\n   *\n   * no globals are left behind\n   */\n\n  // logger.js\n  (function() {\n      'use strict';\n\n      angular\n          .module('app')\n          .factory('logger', logger);\n\n      function logger() { }\n  })();\n\n  // storage.js\n  (function() {\n      'use strict';\n\n      angular\n          .module('app')\n          .factory('storage', storage);\n\n      function storage() { }\n  })();\n  ```\n\n  - Note: For brevity only, the rest of the examples in this guide may omit the IIFE syntax.\n\n  - Note: IIFE's prevent test code from reaching private members like regular expressions or helper functions which are often good to unit test directly on their own. However you can test these through accessible members or by exposing them through their own component. For example placing helper functions, regular expressions or constants in their own factory or constant.\n",
      "rule": "  - Wrap AngularJS components in an Immediately Invoked Function Expression (IIFE).\n",
      "why": "  *Why?*: An IIFE removes variables from the global scope. This helps prevent variables and function declarations from living longer than expected in the global scope, which also helps avoid variable collisions.\n\n  *Why?*: When your code is minified and bundled into a single file for deployment to a production server, you could have collisions of variables and many global variables. An IIFE protects you against both of these by providing variable scope for each file."
    }
  },
  "Modules": {
    "Avoid Naming Collisions": {
      "content": "  - Use unique naming conventions with separators for sub-modules.\n\n  *Why?*: Unique names help avoid module name collisions. Separators help define modules and their submodule hierarchy. For example `app` may be your root module while `app.dashboard` and `app.users` may be modules that are used as dependencies of `app`.\n",
      "rule": "  - Use unique naming conventions with separators for sub-modules.",
      "why": "  *Why?*: Unique names help avoid module name collisions. Separators help define modules and their submodule hierarchy. For example `app` may be your root module while `app.dashboard` and `app.users` may be modules that are used as dependencies of `app`."
    },
    "Definitions": {
      "code": "\n  ```javascript\n  /* avoid */\n  var app = angular.module('app', [\n      'ngAnimate',\n      'ngRoute',\n      'app.shared',\n      'app.dashboard'\n  ]);\n  ```\n\n  Instead use the simple setter syntax.\n\n  ```javascript\n  /* recommended */\n  angular\n      .module('app', [\n          'ngAnimate',\n          'ngRoute',\n          'app.shared',\n          'app.dashboard'\n      ]);\n  ```",
      "content": "\n  - Declare modules without a variable using the setter syntax.\n\n  *Why?*: With 1 component per file, there is rarely a need to introduce a variable for the module.\n\n  ```javascript\n  /* avoid */\n  var app = angular.module('app', [\n      'ngAnimate',\n      'ngRoute',\n      'app.shared',\n      'app.dashboard'\n  ]);\n  ```\n\n  Instead use the simple setter syntax.\n\n  ```javascript\n  /* recommended */\n  angular\n      .module('app', [\n          'ngAnimate',\n          'ngRoute',\n          'app.shared',\n          'app.dashboard'\n      ]);\n  ```\n",
      "rule": "  - Declare modules without a variable using the setter syntax.",
      "why": "  *Why?*: With 1 component per file, there is rarely a need to introduce a variable for the module."
    },
    "Getters": {
      "code": "\n  ```javascript\n  /* avoid */\n  var app = angular.module('app');\n  app.controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```\n\n  ```javascript\n  /* recommended */\n  angular\n      .module('app')\n      .controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```",
      "content": "\n  - When using a module, avoid using a variable and instead use chaining with the getter syntax.\n\n  *Why?*: This produces more readable code and avoids variable collisions or leaks.\n\n  ```javascript\n  /* avoid */\n  var app = angular.module('app');\n  app.controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```\n\n  ```javascript\n  /* recommended */\n  angular\n      .module('app')\n      .controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```\n",
      "rule": "  - When using a module, avoid using a variable and instead use chaining with the getter syntax.",
      "why": "  *Why?*: This produces more readable code and avoids variable collisions or leaks."
    },
    "Named vs Anonymous Functions": {
      "code": "\n  ```javascript\n  /* avoid */\n  angular\n      .module('app')\n      .controller('Dashboard', function() { })\n      .factory('logger', function() { });\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // dashboard.js\n  angular\n      .module('app')\n      .controller('Dashboard', Dashboard);\n\n  function Dashboard() { }\n  ```\n\n  ```javascript\n  // logger.js\n  angular\n      .module('app')\n      .factory('logger', logger);\n\n  function logger() { }\n  ```",
      "content": "\n  - Use named functions instead of passing an anonymous function in as a callback.\n\n  *Why?*: This produces more readable code, is much easier to debug, and reduces the amount of nested callback code.\n\n  ```javascript\n  /* avoid */\n  angular\n      .module('app')\n      .controller('Dashboard', function() { })\n      .factory('logger', function() { });\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // dashboard.js\n  angular\n      .module('app')\n      .controller('Dashboard', Dashboard);\n\n  function Dashboard() { }\n  ```\n\n  ```javascript\n  // logger.js\n  angular\n      .module('app')\n      .factory('logger', logger);\n\n  function logger() { }\n  ```\n",
      "rule": "  - Use named functions instead of passing an anonymous function in as a callback.",
      "why": "  *Why?*: This produces more readable code, is much easier to debug, and reduces the amount of nested callback code."
    },
    "Setting vs Getting": {
      "content": "\n  - Only set once and get for all other instances.\n\n  *Why?*: A module should only be created once, then retrieved from that point and after.\n\n    - Use `angular.module('app', []);` to set a module.\n    - Use `angular.module('app');` to get a module.\n",
      "rule": "  - Only set once and get for all other instances.",
      "why": "  *Why?*: A module should only be created once, then retrieved from that point and after.\n\n    - Use `angular.module('app', []);` to set a module.\n    - Use `angular.module('app');` to get a module."
    }
  },
  "Single Responsibility": {
    "Rule of 1": {
      "code": "  The following example defines the `app` module and its dependencies, defines a controller, and defines a factory all in the same file.\n\n  ```javascript\n  /* avoid */\n  angular\n      .module('app', ['ngRoute'])\n      .controller('SomeController', SomeController)\n      .factory('someFactory', someFactory);\n\n  function SomeController() { }\n\n  function someFactory() { }\n  ```\n\n  The same components are now separated into their own files.\n\n  ```javascript\n  /* recommended */\n\n  // app.module.js\n  angular\n      .module('app', ['ngRoute']);\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // someController.js\n  angular\n      .module('app')\n      .controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // someFactory.js\n  angular\n      .module('app')\n      .factory('someFactory', someFactory);\n\n  function someFactory() { }\n  ```",
      "content": "\n  - Define 1 component per file.\n\n  The following example defines the `app` module and its dependencies, defines a controller, and defines a factory all in the same file.\n\n  ```javascript\n  /* avoid */\n  angular\n      .module('app', ['ngRoute'])\n      .controller('SomeController', SomeController)\n      .factory('someFactory', someFactory);\n\n  function SomeController() { }\n\n  function someFactory() { }\n  ```\n\n  The same components are now separated into their own files.\n\n  ```javascript\n  /* recommended */\n\n  // app.module.js\n  angular\n      .module('app', ['ngRoute']);\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // someController.js\n  angular\n      .module('app')\n      .controller('SomeController', SomeController);\n\n  function SomeController() { }\n  ```\n\n  ```javascript\n  /* recommended */\n\n  // someFactory.js\n  angular\n      .module('app')\n      .factory('someFactory', someFactory);\n\n  function someFactory() { }\n  ```",
      "rule": "  - Define 1 component per file."
    }
  }
}